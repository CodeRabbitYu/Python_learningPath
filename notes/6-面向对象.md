# 6-面向对象

## 6.1 类与实例

* 定义类

```py
class Car:
    # 类的方法在定义时，需要传入参数，否则会报错
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')
```

* 创建对象(类的实例)，对象可以赋予私有属性和方法

```py
class Car:
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')

BMW = Car()
BMW.getCarInfo()
BMW.moveCar()

BMW.color='black'
print(BMW.color) # black

QQ = Car()
# print(QQ.color) # 报错，实例的属性不会影响类
```

* 类的公有属性，__init__方法实际上会自动调用，为类创建公有属性

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue'
            
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')

BMW = Car()
BMW.getCarInfo()
BMW.moveCar()

BMW.color='black'
print(BMW.color) # black

QQ = Car()
print(QQ.color) # blue
```

* self，类中的self关键字指向的是类实例的本身，类似于JS中的this

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue' # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name='' # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args)>0:
            self.name=args[0] # 使用参数列表，可以在创建实例时直接传入属性值

    def getCarInfo(self):
        print('%s车的信息'%self.name)

    def moveCar(self):
        print('%s车在移动'%self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()

BMW = Car('BMW')
# BMW.name='BMW'
BMW.introduce()

BMW2 = Car()
BMW2.introduce()
```

* 类的输出结果，__str__在print(实例)时会自动调用，必须要有返回值

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue' # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name='' # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args)>0:
            self.name=args[0] # 使用参数列表，可以在创建实例时直接传入属性值

        self.introduce()

    def __str__(self):
        return 'self' # __str__必须要有返回值

    def getCarInfo(self):
        print('%s车的信息'%self.name)

    def moveCar(self):
        print('%s车在移动'%self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()

BMW = Car('BMW')
BMW2 = Car()
print(BMW) # self
```

* 注意：禁止在类中对传入的可变类型参数，修改会更改全局变量的值，与函数中相同

```py
class Car:
    def __init__(self, args, **kwargs):
        self.color = (
            "blue"
        )  # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name = ""  # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args) > 0:
            self.name = args[0]  # 使用参数列表，可以在创建实例时直接传入属性值
            # args[0] = "BMW"  # 如果将args转回list类型，则全局变量会被修改
            customName=args
            customName[0] = "BMW" # 由于py中变量的赋值是改变引用地址的指向，所以即使重新生命了私有变量，依然会污染全局变量

        self.introduce()

    def __str__(self):
        return "self"  # __str__必须要有返回值

    def getCarInfo(self):
        print("%s车的信息" % self.name)

    def moveCar(self):
        print("%s车在移动" % self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()


nameB = ["MSN", "MMM"]
BMW = Car(nameB)
BMW2 = Car(nameB)
print(nameB) # ['BMW', 'MMM']
# 可以发现全局变量nameB已经被修改了，因此在传入可变类型的全局变量时，在类中禁止对参数进行重新赋值
```

* 私有属性和私有方法
1. Python中没有像C++中public和private这些关键字来区别公有属性和私有属性，它是以属性命名方式来区分，如果在属性名前面加了2个下划线'__'，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。
2. 私有方法不允许被对象直接调用，一般是在用对象内部的方法进行调用
3. 私有属性仅能通过对象的方法获得，保护数据

```py
class Cars:
    def __init__(self,producer):
        self.__producer=producer

    def set_name(self,attr):
        self.attr=attr
        self.__success('set_name')

    def __success(self,msg):
        print('%s成功'%msg)

    def get_producer(self):
        print(self.__producer)

bmw=Cars('生产者：哈哈哈')
bmw.set_name('bmw') # set_name成功
# bmw.__success('调用') # 会报错，私有方法仅在对象内部可以调用
bmw.get_producer() # 生产者：哈哈哈
# print(bmw.__producer) # 报错，私有属性不可被外部直接调用
```

* 对象的__del__方法会在被删除时调用

```py
class Cars:
    def __del__(self):
        print('del方法被调用')

newCar=Cars()
oldCar=newCar
# 对象的引用地址的链接数,比实际数量大1
import sys
print(sys.getrefcount(newCar)) # 3

del newCar
print(sys.getrefcount(oldCar)) # 2
print('准备删除对象newCar')
print('='*20)
# 准备删除对象newCar
# del方法被调用
# =============

# 这里由于有2个对象指向同一个引用地址，引用地址的链接为2
# 删除对象的引用地址的链接大于1时，del方法会被异步执行，而不是立即调用
```

## 6.2 继承

* 单继承
1. 私有的属性，不能通过对象直接访问，但是可以通过方法访问(不允许跨级)
2. 私有的方法，不能通过对象直接访问
3. 私有的属性、方法，不会被子类继承，也不能被访问
4. 一般情况下，私有的属性、方法都是不对外公布的，往往用来做内部的事情，起到安全的作用

```py
# 父类
class Animal:
    def eat(self):
        print('吃')

    def drint(self):
        print('喝')

    def sleep(self):
        print('睡')

# cat=Animal()
# cat.eat() # 吃

# 子类
class Dog(Animal):
    def bark(self):
        print('汪汪')

# dog1=Dog()
# dog1.eat() # 吃
# dog1.bark() # 汪汪

class FlyDog(Dog):
    def fly(self):
        print('飞天狗')

    # 重写bark方法
    def bark(self):
        print('飞天狗汪汪叫')

        # 调用被重写的方法
        # 方法1 调用方法的所属类名.方法(self)，参数self必传
        Dog.bark(self) # 汪汪
        # 方法2 super()表示上一级的类
        super().bark() # 汪汪

flydog1=FlyDog()
flydog1.eat() # 吃
flydog1.bark() # 飞天狗汪汪叫
flydog1.fly() # 飞天狗
```

* 多继承

```py
# 定义一个父类
class A:
    def printA(self):
        print('----A----')

# 定义一个父类
class B:
    def printB(self):
        print('----B----')

    def test(self):
        print('test-A')

# 定义一个子类，继承自A、B
class C(A,B):
    def printC(self):
        print('----C----')

    def test(self):
        print('test-B')

obj_C = C()
obj_C.printA() # ----A----
obj_C.printB() # ----B----
obj_C.test() # test-B 按照对象搜索方法是的先后顺序
print(C.__mro__) #可以查看C类的对象搜索方法时的先后顺序
# (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

## 6.3 多态

* 所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态。多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。

* Python伪代码实现Java或C#的多态

```py
class F1(object):
    def show(self):
        print('F1.show')

class S1(F1):
    def show(self):
        print('S1.show')

class S2(F1):
    def show(self):
        print('S2.show')

# 由于在Java或C#中定义函数参数时，必须指定参数的类型
# 为了让Func函数既可以执行S1对象的show方法，又可以执行S2对象的show方法，所以，定义了一个S1和S2类的父类
# 而实际传入的参数是：S1对象和S2对象

def Func(F1 obj):
    # Func函数需要接收一个F1类型或者F1子类的类型
    print(obj.show())

s1_obj = S1()
Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.show

s2_obj = S2()
Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show
```

* Python “鸭子类型”

```py
class F1(object):
    def show(self):
        print('F1.show')

class S1(F1):
    def show(self):
        print('S1.show')

class S2(F1):
    def show(self):
        print('S2.show')

def Func(obj):
    print obj.show()

s1_obj = S1()
Func(s1_obj)

s2_obj = S2()
Func(s2_obj)
```
