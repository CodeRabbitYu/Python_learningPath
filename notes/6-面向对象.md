# 6-面向对象

## 6.1 类与实例

* 定义类

```py
class Car:
    # 类的方法在定义时，需要传入参数，否则会报错
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')
```

* 创建对象(类的实例)，对象可以赋予私有属性和方法

```py
class Car:
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')

BMW = Car()
BMW.getCarInfo()
BMW.moveCar()

BMW.color='black'
print(BMW.color) # black

QQ = Car()
# print(QQ.color) # 报错，实例的属性不会影响类
```

* 类的公有属性，__init__方法实际上会自动调用，为类创建公有属性

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue'
            
    def getCarInfo(self):
        print('车的信息')

    def moveCar(self):
        print('车在移动')

BMW = Car()
BMW.getCarInfo()
BMW.moveCar()

BMW.color='black'
print(BMW.color) # black

QQ = Car()
print(QQ.color) # blue
```

* self，类中的self关键字指向的是类实例的本身，类似于JS中的this

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue' # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name='' # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args)>0:
            self.name=args[0] # 使用参数列表，可以在创建实例时直接传入属性值

    def getCarInfo(self):
        print('%s车的信息'%self.name)

    def moveCar(self):
        print('%s车在移动'%self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()

BMW = Car('BMW')
# BMW.name='BMW'
BMW.introduce()

BMW2 = Car()
BMW2.introduce()
```

* 类的输出结果，__str__在print(实例)时会自动调用，必须要有返回值

```py
class Car:
    def __init__(self, *args, **kwargs):
        self.color='blue' # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name='' # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args)>0:
            self.name=args[0] # 使用参数列表，可以在创建实例时直接传入属性值

        self.introduce()

    def __str__(self):
        return 'self' # __str__必须要有返回值

    def getCarInfo(self):
        print('%s车的信息'%self.name)

    def moveCar(self):
        print('%s车在移动'%self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()

BMW = Car('BMW')
BMW2 = Car()
print(BMW) # self
```

* 注意：禁止在类中对传入的可变类型参数，修改会更改全局变量的值，与函数中相同

```py
class Car:
    def __init__(self, args, **kwargs):
        self.color = (
            "blue"
        )  # 此时self指向的是实例的引用地址 <__main__.Car object at 0x00000168C5D0FF98>
        self.name = ""  # 由于类的方法用到name属性，此时声明可以避免报错
        if len(args) > 0:
            self.name = args[0]  # 使用参数列表，可以在创建实例时直接传入属性值
            # args[0] = "BMW"  # 如果将args转回list类型，则全局变量会被修改
            customName=args
            customName[0] = "BMW" # 由于py中变量的赋值是改变引用地址的指向，所以即使重新生命了私有变量，依然会污染全局变量

        self.introduce()

    def __str__(self):
        return "self"  # __str__必须要有返回值

    def getCarInfo(self):
        print("%s车的信息" % self.name)

    def moveCar(self):
        print("%s车在移动" % self.name)

    def introduce(self):
        self.getCarInfo()
        self.moveCar()


nameB = ["MSN", "MMM"]
BMW = Car(nameB)
BMW2 = Car(nameB)
print(nameB) # ['BMW', 'MMM']
# 可以发现全局变量nameB已经被修改了，因此在传入可变类型的全局变量时，在类中禁止对参数进行重新赋值
```
